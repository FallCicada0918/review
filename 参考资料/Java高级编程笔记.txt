流程控制
  顺序执行
  分支结构
    if(){

    }else{

    }
    if-else if-else
    switch case
      switch()
        case 1:
          语句体1;
          break;
        case 2:
          语句体2;
          break;
        ...
        default:
          所有条件都不匹配，执行这里的语句;
    如果满足条件的case语句没有加break，那么代码会顺序往下执行，直到遇到break，如果一直没有break，那么会执行default后结束
  循环结构
    for 
      for(初始化语句；条件判断语句；条件控制语句){
        // 循环语句体
      }
      // 死循环
      for(;;){

      }
    while 
      while(条件判断语句){
        循环语句
        条件控制语句
      }
      // 死循环
      while(true){

      }
    do-while
      do{
        循环语句
        条件控制语句
      }while(条件判断语句)
      // 死循环
      do{
        
      }while(true)
    循环中的几个关键字
      break; 
        跳出当前循环
        循环语句遇到break关键字，循环直接结束
      continue;
        结束本次循环，进入到下一次循环
      label;
        代码中出现多层循环嵌套，label标签配合break关键字，可以使程序从内部循环中跳出
        如果想让break或continue针对某一个指定的循环起作用，那么可以使用label标签 给循环起名字，然后 使用break或continue加上label标签名即可。
    循环嵌套
      一个循环内部可以嵌套另一个或者多个循环
      双层for循环
方法 
  就是完成特定功能的代码块
  通过方法的定义和调用，可以大大提高代码的复用性和可读性   
  定义格式：
    修饰符  返回值类型 方法名  形参列表 形式参数列表
    public void     main  (){
      // 方法体

    }
    public int getSum(int a,int b){
      return a + b;
    }
    getSum(1,2);
  规范
    小驼峰命名法 main getStudentById getAvg
    见名知意 
方法重载
  同一个类中，如果函数名相同，但是参数列表不同（参数的数据类型不同、参数的个数不同），就构成方法的重载
  重载与返回值类型无关
面向对象语言的三大特征
  继承、封装、多态
封装
  是面向对象语言的三大特征，另外两个是继承和多态
  封装 隐藏对象的属性和实现的细节 仅对外提供公共的访问方式
    提高安全性
    用户不需要知道内部具体复杂的实现。只需要使用对应的功能即可
  封装的原则
    把不需要对外提供的内容隐藏起来
    把属性隐藏掉，提供方法来修改，保证数据的安全
      属性：
        余额
      stu1.name = "张三";
      card.balance = 10000;
  封装的实现
    1. 用 private 修饰成员属性（成员变量）
    2. 提供对应的公开的 public set和 public get方法
继承
  继承是属于类与类之间的一种关系
  继承是面向对象语言的三大特征之一 
  java中类继承是单继承，一个子类只能继承一个父类(一个父亲)
  java中不能多继承，以下代码编译报错
    public class Student extends Person,Animal
  多层继承
    子类A继承父类B，
    父类可以继承爷爷类C
    A extends B{}
    B extends C{}
  java中接口是多实现，一个接口能实现多个接口(老师、师傅)
  动物类
    狗类
    猫
    熊猫
    鳄鱼
    Person类
      Teacher类
      Student类
  继承的实现
    [public] class 子类名 extends 父类名{
      // 可以直接继承父类的属性和方法
      // 实现子类的新增内容
    }
  父类：也称为 基类、 超类 super
  子类：派生类
  子类能够继承父类的属性，但是如果父类的属性是私有的，那么子类无法直接访问
  子类只能继承父类的所有非私有的成员变量和成员方法
  官方文档：
  从继承的概念来说，private修饰的成员不被继承，
  但是，如果超类中具有访问其私有字段的非私有（公开、受保护）方法，那么子类也可以使用这些方法
  子类如何访问父类中的私有成员变量？
  static成员变量或方法
    访问性：如果子类中没有定义与父类同名的成员变量或方法，那么子类可以访问父类中的静态变量和方法
    如果子类中定义了与父类同名的成员变量或方法，那么子类访问的是自己的静态变量和方法
    虽然静态成员不是通过继承机制获得的，但子类可以通过继承获得访问父类静态成员的权限
Object类
  toString();
  java中类如果没有指明继承的父类，那么默认继承Object类
    public class Animal {
      编译后
    public class Animal extends Object{
  Object类中没有成员属性，只有方法
  常用的就是toString()、equals()
  是java继承体系中的最顶层父类
继承的优点和缺点
  优点
    提高代码的复用率
    提高代码的维护性 小问题的话 修改父类一处即可，不需要到每个子类中修改
  缺点
    代码与代码之间存在关联，这种关系叫耦合
    继承，让类与类之间产生了耦合，降低代码的灵活性，父类如果有变化，子类不得不适应
重载
  类中 同名方法 参数列表（数量、类型都算）不同，与返回值类型无关 
重写
  继承关系中，当子类需要父类的功能，而继承的方法不能完全满足需求，可以重写父类的方法，这样沿袭了父类的功能，又定义了子类特有的内容
  特点
    子类和父类方法名要相同
    参数列表要完全相同
    方法的返回值类型可以相同，可以不同（先按相同处理，不同的情况后面补充）
    异常类型的抛出的范围可以缩小，不能扩大（后面补充）
    权限修饰符范围可以扩大，不能缩小
      public protected default private
    子类继承父类，在调用方法时，如果子类中有重写，那么就用重写的方法，
    如果没有重写，就用父类中的方法。
    父类中的私有方法(未被继承),不能被子类重写
    静态成员方法不能被子类重写
    因为Object是顶级父类，那么比如toString()方法能被所有类的对象直接使用
    @Override 注解
    作用： 提供了一种额外的检查机制和代码清晰度。
      1. 代码层面提醒程序员注意编程规范：重写、接口的实现
      2. 编译器检查 检查是否是重写 有助于尽早发现错误
    重写 toString 方法
    final 最终
      final修饰的方法不能被重写
final
  final修饰的类  不能被继承   那么如果非要去继承，报什么错？
  final修饰的方法不能被重写， 可以被继承吗？
  final修饰的属性（变量）的值不能更改 常量
    数据类型：基本 值不能修改
            引用 地址值不能修改，地址对应的内容是可以改变的
  1.final修饰的类  不能被继承 ，那么如果非要去继承，报什么错？
  2.final修饰的方法不能被重写，可以被继承
  3.String 类可否被继承？ 不可以 final修饰的
  4.final修饰的属性（变量）的值不能更改，如果非要去更改，报什么错？
权限修饰符
  public      公共的 在所有地方都可以访问
    public class
  protected   受保护的 当前类、子类、同一个包中的其他类
     protected class
  default   （指默认 default不是一个修饰符）默认 当前类、子类
    class
  private     私有的 当前类
多态
  面向对象语言的三大特征之一
  一种事物，有多种状态
  java中多态怎么实现
    子类继承父类
    子类要重写父类的方法
    父类的引用指向子类对象（一个父类的引用可以指向任何一个子类的对象）
      Animal a = new Dog();
    父类的引用调用子类重写的方法
  java中完全相同的代码出现在不同的位置，执行的结果不同
    point.show();
抽象
  抽象类
    包含抽象方法的类，那么必须声明为抽象类。
    抽象类可以包含抽象方法，也可以不包含抽象方法
    关键字 abstract
    public abstract class Animal
    抽象类可以包含成员属性、成员方法、构造器等内容
    抽象类不可以实例化对象
接口 interface
  特点
    引用数据类型中的一种：类 接口 数组
    java中的接口是对单继承的一个补充，在开发过程中想增强类的功能，可以借助接口去实现，接口是多实现（比如一个人可以有多个老师）
    接口文件编译后生成.class 但是接口和类不是同一种东西
    public interface IAction {}
    注意1， 定义类使用关键字 class ，定义接口使用关键字 interface
    注意2，接口中的数据成员，默认 public static final 修饰，是常量，名称一般全大写
    注意3，接口中的方法，默认 public abstract 修饰，是抽象方法
    接口和类不一样，接口不可以实例化对象，没有构造方法
    接口是用来实现的，而不是继承
    接口是多实现的，但是
    接口的实现类要重写接口的所有抽象方法
    Java中类的继承是单继承，接口和接口之间是多继承
类与接口的区别
  类与类之间是单继承、但是是多层继承
  类与接口之间是实现关系，一个类可以在继承一个类的情况下，同时实现多个接口
  接口和接口之间的关系
    继承关系，可以单继承，也可以多继承
内部类
  在一个类的内部定义另外一个类，就是内部类
  编译后，外部类和内部类都会生成字节码文件
  内部类的使用：
    1. 比如ArrayList中 就有多个内部类的使用
    2. 类与类之间的包含关系 比如汽车类 包含发动机 发动机也是一个类 此时就可以使用内部类的概念来处理这种关系
  分类
    成员内部类
    静态内部类
    局部内部类
    匿名内部类
  成员内部类 
    在类中，可以定义成员属性、成员方法，还可以定义成员内部类
    成员内部类的定义位置：类中，方法外
    在成员内部类中不能定义静态成员变量和成员方法
    实例化一个内部类 Inner 的对象
      外部类名.内部类名 对象名 = 外部类对象.内部类对象;
      Outer.Inner inner = new Outer().new Inner();
      Outer.Inner inn = this.new Inner();

      // 创建一个外部类的对象
      Outer out = new Outer();
      // 创建一个内部类的对象
      Outer.Inner inn = out.new Inner();
      Outer.Inner inn2 = new Outer().new Inner();
    在外部类中实例化自己的成员内部类对象的3种方式
      1. Outer.Inner inner = new Outer().new Inner();
      2. Outer.Inner inner = this.new Inner();
      3. Inner inner = new Inner();
    编译后，外部类和内部类都会生成字节码文件
      Outer.class
      Outer$Inner.class
  静态内部类  
    定义在类中，方法外；
    用static修饰的成员内部类叫静态内部类
    静态内部类中成员方法，只能访问外部类中的静态成员或静态方法。
    在成员内部类中不能定义静态成员变量和成员方法，在静态内部类中，可以定义静态成员和静态方法
    外部类的方法是能访问静态内部类的所有成员和方法
  局部内部类 (很少使用)
    定义在类中的方法中
    在外部类的方法中定义的内部类，叫局部内部类，作用范围在当前方法中
    从内部类引用的本地变量必须是最终变量或实际上的最终变量 final
  匿名内部类（重点掌握） 
  定义
    没有名字的内部类，也是特殊的局部内部类（定义在方法内部）
    定义位置要结合使用场景考虑
      Animal animal = new Animal("狗子") {
        // 匿名内部类的实现
      }
  使用场景
    实现接口
      利用接口进行声明并创建匿名内部类对象，这个匿名内部类默认就是接口的实现类
    继承抽象父类  
      利用父类进行声明并创建匿名内部类对象，这个匿名内部类就是父类的子类
  核心任务
    匿名内部类的核心任务是重写抽象方法，然后就可以调用重写的方法
  注意事项
    匿名内部类必须依托于一个接口或者一个父类（可以是抽象类，也可以是普通类）
    匿名内部类在声明的时候就要去创建对象，否则后面无法调用（比如简化的写法，只能调用一次）
    匿名内部类中无法定义构造器
  匿名内部类使用父类构造器的方法
  Animal animal = new Animal("狗子") {
    // 匿名内部类的实现
  }
Object
  是所有类的父类
String 
  常用属性
枚举
  是java中一种特殊的类
  用于定义对象个数固定的类，比如性别类
  关键字：enum 替代 class
集合
  数组
    长度是固定的：在创建数组时就需要指定数组的长度，并且在创建后不可以改变
    数据类型是固定的：在创建数组时就需要指定数组的数据类型，并且在创建后不可以改变，该数组只能存储指定数据类型的数据
    数组在堆空间的内存是连续的：所以当插入一个元素的时候，后面的元素要整体移动，导致效率低下
  介绍
    在java中，集合是一种数据结构，是用于储存和操作一组对象。主要用于解决数组中不太好处理的问题
    集合位于java.util包中，提供了一系列的接口和类
      接口： Collection 、List、Map
      类：Set
  集合和数组的区别
    1. 数组的长度是固定的
      集合的长度是可变的
    2. 数组中元素类型是相同的
      集合中可以存储不同类型的数据
    3. 数组可以存放基本数据类型和引用数据类型的数据
    集合只能存放引用数据类型数据
    4. 数组是由JVM中现有的数据类型+[]组合而成的，除了一个length属性，和从Object继承的方法之外，数组就调用不到其他属性和方法了
    但是集合是由java.util包下的多个接口和实现类组成，定义并实现了很多方法，功能强大
  集合框架体系的组成
    接口 
      是整个集合框架的上层结构，接口中定义了集合中必要的基本方法
      接口还把集合划分为几种不同的类型，每一种集合都有自己对应的接口
    实现类
      去实现上层规划好的接口，每个接口都有对应的实现类
    数据结构
      不同的接口实现类，存储数据的方式不同，也就是使用的数据结构不同
  集合分类
    单列集合
      每个集合元素只包含一个单独的对象，是集合框架中最简单的形式
    多列结合
      每个集合的元素由多个列组成，可以同时存储和操作多个相关的值
  集合章节学习的基本要求
    1. 会用集合存储数据
    2. 会从集合中取出数据
    3. 掌握每种集合的特点和应用场景
  Collection 
    Collection 接口是单列集合类的父接口 它有两个重要的子接口
    1. List 
    2. Set 
    Collection是父接口，定义了子接口（List、Set）的通用方法
    Collection 接口的实现类，都可以使用这些方法
  方法
    add()
      作用：向集合中添加元素
      参数：Object 类型的元素
      返回值：boolean
    isEmpty()
      作用：判断当前集合是否为空
      参数：没有
      返回值：boolean
    clear()
      作用：清空集合中所有元素
      参数：无
      返回值：无
    remove()
      作用：从集合中删除指定元素
      参数：Object
      返回值：boolean
    size()
      作用：返回集合中元素的个数
      参数：无
      返回值：int
      注意： If this collection contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
    toArray()
      作用：将集合中的元素放到数组中
      参数：无
      返回值：Object[]
    c1.addAll(c2)
      作用：将c2整体添加到c1中
      参数：集合
      返回值：boolean
    c1.contains("hello")
      作用：判断集合中是否包含该对象
      参数：Object
      返回值：boolean
      注意：用的是equals
    c1.containsAll(c2);
      作用：判断c1中是否完整包含c2中的对象
      参数：集合
      返回值：boolean
     c1.remove("hello");
      作用：删除指定元素 借助 equals判断
      参数：Object
      返回值：boolean
    c1.removeAll(c2);
      作用：删除整个c2集合中的元素，底层：遍历，逐个比较，然后删除
      参数：结合
      返回值：boolean

    contains 、remove等方法底层借助的是equals方法区进行比较，如果集合存放自定义类的对象，注意重写方法（equals，toString）
  集合的遍历
    1. 使用 toArray() 将集合的元素放到数组中，再去遍历
    2. 使用增强for循环直接遍历集合(Collection以及他的子类型)
    3. 迭代器 Iterable
      是集合框架提供的一种遍历集合元素的方式
      是一个接口
      通过 hasNext() 方法判断集合是否还有下一个元素 
      使用 next() 方法，获取下一个元素
      迭代器是单向的 只能从前往后 无法倒序
      在迭代器遍历时，不要修改集合的结构，修改可能会导致异常(ConcurrentModificationException)
  List接口
    介绍
      继承了Collection接口，也是常用的一种集合类型 
      ArrayList这个类是List接口的实现类
    特点
      是一种有序集合
      是带索引的集合 可以通过下标索引去精确查找元素
      可以存放重复元素（没有去重功能）
    常用方法
      size()
      get(int index)
        作用：查找集合中指定位置的元素
        参数：int 索引
        返回值：找到：指定位置的元素、没找到：IndexOutOfBoundsException
      list.indexOf("hello1");
        作用：查询指定元素的第一次出现的下标，从前往后查
        参数：元素
        返回值：index或者-1
      list.lastIndexOf("hello1");
        作用：从后往前查
        参数：
        返回值：
      set(int index, E element)
        作用：用 value 替换 index 位置的元素
        参数：
        返回值：指定位置的旧元素
      add( E element)
        作用：
        参数：
        返回值：boolean
      add(int index, E element)
        作用：将指定的元素，添加到集合的指定位置，集合的size+1
        参数：index的范围[0，size()]
        返回值：void
      list.addAll(集合)
        作用：
        参数：
        返回值：
      list.addAll(index，集合)
        作用：从指定位置开始，把集合元素添加进来
        参数：
        返回值：boolean
      remove("元素")
        作用：删除第一个被找到指定元素，Size - 1
        参数：
        返回值：boolean
      remove(int index)
        作用：移除指定位置的元素，并返回该元素，Size - 1
        参数：index的范围[0，size()]
        返回值：boolean
      list.removeAll(list)
        作用：
        参数：
        返回值：
      list.subList(fromIndex, toIndex)
        作用：截取集合中的一部分数据
        参数：左闭右开
        返回值：截取的集合
    ArrayList 
      是最常用的List类型的集合，ArrayList类的底层就是用数组实现的数据的存储 特点：增删慢，查找快
      在日常开发中，查询功能一般是使用最多的，所以ArrayList是最常用的
      位置：java.util.ArrayList
    LinkedList 
      底层使用的数据结构是双向链表，和ArrayList相反，特点是增删快，查找慢，注意：这里强调的快慢，是对大量数据的操作，至少要上万条数据，如果数据量不大，几乎没有区别
      常用方法  
        pop() 
          从该列表表示的堆栈中弹出一个元素。换句话说，删除并返回此列表的第一个元素。此方法等效于removeFirst（）。
        push()
          将元素放入list中 等效addFirst
    Vector
      介绍
        线程安全，功能和使用方式和ArrayList非常相似
        ArrayList，非线程安全，但是在单线程环境下性能更高效
        是List接口的实现类，内部也是采用数组来存储数据
      方法
        add("hello");
        vector.addElement("world");
  List特点
    ArrayList
      内部使用数组实现
      动态调整大小
      读取快，插入删除慢
    LinkedList
      内部使用双向链表实现
      动态调整大小
      读取慢，插入删除快
    Vector
      内部使用数组实现
      动态调整大小
      多线程环境安全 
  数据结构
  Set集合
    介绍
      java.util.Set
      是一个接口 继承了 Collection 接口
      是一种常见的集合类型
    特点
      Set是一种无序的集合
      Set是不带下标索引的集合
      Set不能存放重复数据的
    实现类
      比较重要的两个实现类
      HashSet（直接实现类）
        java.util.HashSet 
          是set的实现类
          使用hash表作为底层的数据结构来存储数据
        特点 
          无序：元素的存储顺序和插入顺序无关
          因为用到的是哈希表，哈希表是根据元素的哈希值来确定存储位置，哈希值是根据元素的内容计算得到的，所以与插入顺序无关。
          唯一：HashSet不允许重复数据，所以每一个元素都是唯一的
          允许存放null元素，但是只能存一个
          高效：
            插入、删除和查找都是比较高效的
            哈希表通过将元素的哈希值映射到数组的索引来实现快速插入、删除和查找
        方法：
          获取元素的hash值 
          hashCode()方法是Object类的一个方法，
            作用：  获取一个对象的hash值
            参数：  无
            返回值：int 哈希值
            特点： 
              如果两个对象的hashCode值不同，那这两个对象的属性值有可能相同，有可能不同
              如果要用HashSet存放自定义类型的元素，要重写HashCode方法
      TreeSet（Set的子接口SortedSet的实现类）
        介绍：
          Set的子接口SortedSet的实现类
          数据结构：红黑树 red-black tree
        特点：
          有序性：插入、删除元素时会自动排序，（注意：并不是插入的顺序）
          唯一 
          高效  
            具有快速的查找和插入的特性，对于有序集合的操作，TreeSet通常比HashSet更高效
        注意：  
          排序规则：
            1. 自然排序（默认规则）
              元素的类要实现这个接口java.lang.Comparable
              重写 compareTo 这个方法
              compareTo方法说明  
                int result = this.属性.compareTo(o.属性);
                result 值如果大于 0  那么 this比o大
                result 值如果小于 0  那么 this比o小
                result 值如果等于 0  那么 this=o
                result的值不关心具体是多少，只关心是正数、负数还是0
            2. 比较器排序
              如果要排序的对象不好去重写源码
              使用比较器去自定义排序规则
              Set<Student> studentSet = new TreeSet<>(comp);
            特点：  
              自然排序和比较器排序可以同时存在，比较器排序会覆盖自然排序 
              比较器可以有多个
      HashSet的一个子类 LinkedHashSet 
        具有高效性和唯一性，而且会保持元素的插入顺序，基于哈希表和链表实现
        Set<String> set = new LinkedHashSet<String>();
        自行测试相关属性
    总结
      HashSet

      TreeSet

      LinkedHashSet
  Map 
    实现类 
      HashMap
        介绍
          底层实现：哈希表
        特点：  
          元素的存取顺序不能保证一致
          HashMap存储键值对时，如果键的类型为自定义类型，要注意重写hashCode、equals方法（比如用到remove、containsKey或者containsValue时）

          键是唯一的，每个键只能对应一个值
          值是可以重复的，不同的键可以对应重复的值
          无序的 
          线程不安全
          键和值可以为null
      Hashtable
        相对于HashMap，性能稍差一点，但是线程安全
        键和值都不能为null
      TreeMap
        TreeMap有序的，他是SortedMap接口的实现类 基于红黑树存放键值对
        键的排序：自然排序或者比较器排序
        线程不安全
        键是唯一的 值是可以重复的，不同的键可以对应重复的值
      LinkedHashMap
        是HashMap的子类
        有序：插入顺序

  泛型 Map<K, V>
    介绍：  
      在java中，泛型是一种强大的特性，它允许在类、接口和方法中定义类型参数，这些类型参数在类被实例化或方法被调用时会被具体的类型替代。使代码更加通用，提高代码的可读性和可维护性
    自定义案例
      自定义泛型类
      自定义泛型接口
      自定义泛型方法
异常 
  介绍：
    程序运行过程，由于意外情况导致程序发生异常事件，一般情况下，程序会中断，此时java会抛出一个异常类型的对象，用来表示此时程序出现的问题
  作用：
    定位异常发生的位置，以及异常发生的原因
  体系
    异常体系中的根类是： java.lang.Throwable ，该类下面有俩个子类型，
    java.lang.Error 和 java.lang.Exception
  主要讲解 Exception
  异常的种类
    编译时异常
      继承自 Exception 类，也称为checked exception
      编译器在编译期间，会主动检查这种异常，如果发现异常则必须显示处理，
      否则程序就会发生错误，无法通过编译
    运行时异常
      RuntimeException 类及其子类，也称为unchecked exception
      编译器在编译期间，不会检查这种异常，也不要求我们去处理，但是在运行期间，如果出现这种异常则自动抛出
   异常传播
    如果一个方法中出现了异常的情况，系统默认的处理方式是：自动创建异常对象，并将这个异常对象抛给当前方法的调用者，并一直向上抛出，最终传递给JVM，JVM默认处理步骤有2步：
      把异常的名称，错误原因及异常出现的位置等信息输出在了控制台
      程序停止执行
  异常抛出
    自动抛出
      ArithmeticException
      NullPointerException 等
    手动抛出
      手动抛出异常固定格式：
        throw 异常对象;
      if("root".equals(name) && "briup".equals(passwd)) {
      System.out.println("登录成功!");
      }else {
      //抛出运行时异常
      throw new RuntimeException("用户名或密码录入有误");
      }
  异常处理
    默认的处理方式
      1. 抛出异常对象、原因、位置
      2. 终止程序
    手动处理 
      声明继续抛出异常，借助throws关键字实现
      捕获并处理异常，借助try、catch、finally关键字实现
    throws 关键字用于在方法声明中指定该方法可能抛出的异常类型。
    这个声明的目的，就是告诉方法的调用者，你调用我的这个方法的时候要小心
    啦，方法在运行的时候可能会抛出指定类型的异常
  throws throw
    区别
      throw 
        方法中
        抛出一个异常对象
      throws
        定义方法时使用 在形参列表后
        声明方法可能抛出的异常，可以有多个
        throws Exception, IOException 

  异常方法
    Exception 类中并没有定义其他方法 它的方法都是从 Throwable 中继承过来的，
    printStackTrace() ，打印输出当前发送异常的详细信息（重要）
    getMessage()
  try-catch-finally
    try-catch 语句块，就是用来对指定代码，进行异常捕获处理，并且处理完成后，JVM不会停止运行，代码还可以正常的往下运行！
  自定义异常
    如果要自定义一个编译时异常类型，就自定义一个类，并继承  Exception
      如果要自定义一个运行时异常类型，就自定义一个类，并继承RuntimeException
多线程 
  进程 
    进程就是指内存中运行的应用程序，是系统运行程序的基本单位
    一个程序从创建、运行到消亡的过程，就是一个进程
    一个操作系统可以同时运行多个进程，每个进程运行时，系统都会为他分配独立的内存空间
  线程 
    线程是进程的执行单元，一个进程包含一个或多个线程
    如果一个程序有多个线程，那就是多线程程序
  并发
    两个或多个事件在同一时间段内发生
    是指在一个时间段内（微观），两个或多个线程，使用同一个CPU交替运行
  并行
    两个或多个事件在同一时刻发生（同时发生）每个事件各自使用一个CPU同时运行
  线程调度
    时间片 微秒纳秒级别 不同的线程占用这个时间片完成自己的任务
    线程执行时，如果时间片结束，那么该线程会停止运行，并且交出CPU使用权，等待下一个时间片的分配
    所以实际是交替运行，但是时间很短，所以宏观上不容易察觉
  调度方式
    时间片轮转
      多个线程轮流使用CPU的使用权，平均分配使用时间
    抢占式调度
      系统会让优先级高的线程优先使用CPU
  线程创建
    import java.lang.Thread;
    Thread 是java中的线程类 所以所有的
    线程对象都要是Thread类的、或者Thread类的子类的对象
    方式1：
      通过继承Thread类，来创建线程对象并启动线程
      需要单独创建文件，适用于run方法比较庞大的情况
    方式2：
      通过匿名内部类创建子线程
      无需要单独创建文件，适用于run方法比小的情况
    方式3：
    使用自己实现的Runnable接口的类去完成线程创建
    run()
    Thread(Runnable target)
    Thread(Runnable target, String name)
  main线程
    使用java指令运行类的时候，首先启动jvm，jvm会创建一个线程main，来执行main方法
  分类(代码位置P20)
    前台线程  执行线程、用户线程
    后台线程  守护线程、精灵线程
  优先级
    线程类 有一个属性叫优先级 1-10 默认：5
    线程的优先级越高，越容易获取CPU的时间片，获取的概率更高，可能有效，可能无效
  线程组(位置P27)(简单了解，代码敲一遍)
    ThreadGroup 去管理一批线程
  线程状态
    使用的是枚举类型
  方法： 
    int getPriority()
      获取线程的优先级
    getPriority()
      设置优先级 1-10
  方法：
    run()
    start()
    sleep(毫秒)
      指定线程休眠的毫秒数
    join()
      让当前线程 等待另一线程 死等 等另一个结束
    join(毫秒)
      等毫秒时间结束，继续执行
    exit()
    getName() 获取线程的名字
    setName() 设置线程名称
    public Thread(String name);
    public Thread(Runnable var1, String name) {}
      Thread t = new Thread("线程名字2") {}
    Thread.currentThread();
      获取执行当前方法的线程
  线程安全 
    如果有多个线程，它们在一段时间内，并发访问堆区中的同一个变量（含写入操作），那么最终可能会出现数据和预期结果不符的情况，这种情况就是线程安全问题
  线程同步
    java提供了线程同步的机制，用来解决线程不安全的问题
    java中实现线程同步的一个关键字 synchronized
    线程同步方式： 
      同步代码块
      同步方法
    锁机制注意：
      所有线程必须使用同一个锁对象
      所有线程都必须要参与线程同步
    同步代码块
      synchronized(锁对象){
        // 需要同步的操作
      }
    同步方法
      使用synchronized修饰的方法
      public static synchronized 返回值类型 方法名(){
        // 需要同步的操作 可能产生线程安全问题的代码
      }
      注意：
        同步方法可以是静态的 也可以是非静态的
        普通同步方法的锁：默认的锁对象是 this
        静态同步方法的锁：类的字节码对象 Printer.class
    锁机制
  线程通信
    线程同步synchronized只能保证线程在执行时不被打断，但是不能保证执行的顺序，想要控制顺序，就要用到线程通信
    等待唤醒机制
      Object类提供了以下三个方法
        wait() notify() notifyAll() 
        Object mutex = new Object();
        当一个对象mutex在synchronized同步代码块中，被当成锁对象使用时，该对象可以调用这些方法
      注意：
        1.任意对象都有这三个方法
        2.只有对象被当成锁对象使用时，该对象可以调用这些方法
        3.在synchronized同步代码块中才能调用
        其他情况调用会报错 报什么错？
        4.  wait() notify() notifyAll() 这些年方法必须要由同一个锁对象去调用
      3. 消费者 吃包子 1个
    注意：
      1. 三个及以上的线程通信，需要wait notifyAll flag去完成
      2. notifyAll会唤醒所有线程 这个线程有可能不是我们想要的
      3. 所以需要用while去判断一次条件（必须用while判断）
  死锁
  线程池
文件
  文件、目录（文件夹）
  相对路径和绝对路径
  方法： 
    length()
      表示文件的长度 
      对于目录（文件夹）返回值未指定 一般是 0 
    delete()
      如果方法的调用者是非空目录，不会删除
      只能删除空目录
IO流 （输入输出流）
      input   输入  文件、内存或者网络 流向程序
      output  输出  程序流向 文件、内存或者网络
    Streams 流 形容的是数据在程序与设备之间的流动传输
      字节流 以字节(byte)为单位
      字符流 以字符(char)为单位
    分类：
      字节输入流  InputStream
      字节输出流  OutputStream
      字符输入流  Reader
      字符输出流  Writer
    字节流 
      字节输入流  InputStream 是所有字节输入流的抽象父类
      字节输出流  OutputStream是所有字节输出流的抽象父类
      一般在操作数据时，往往是使用一对，一个负责读取数据，一个负责写数据，都是使用这两个父类的子类对象。
      一切的数据文件（文本、图片、音频、视频），在计算机中，都是以二进制数字的形式保存，都是一个个的字节，所以在传输数据时，字节流可以传输任意类型数据
      明确无论使用什么流，最终底层都是二进制数据
      方法：
        read()
          返回值 int 
          参数 空 
          用处： 每次读取1个字节 当读到文件末尾返回-1
        read(bytes)
          返回值 int 
          参数 bytes数组 
          用处： 第一次就将读到的字节存入数组中，返回值是读取到的字节数
          如果多次读取，最后一次读取到文件末尾返回-1
        read(bytes, 3, 5);
          读取字节流，输出的结果向后偏移3个字节[0,0,0,97,98,99,]
          读取5个字节 如果读取成功 则返回实际长度
          如果返回-1 读取到文件的末尾
      创建FileOutputStream的时候，如果文件不存在，会自动创建，但是路径中的目录不存在，会抛出异常（FileNotFoundException）
      方法：
        write(bytes, 0, 3);
      文件追加  
        FileOutputStream(path,true);
      内存输出流
        使用内存流可以操作内存中字节数组中的数据，所以内存字节流也叫字节数组流
        ByteArrayOutputStream
        ByteArrayInputStream
    字符流 
      介绍 
      方法
  IO流按照功能划分的分类
  节点流（原始流）  
      是最基本的IO流，直接与数据源或者目标进行交互，但是缺乏高级功能
      FileInputStream、FileOutputStream 字节流
      FileReader、FileWriter 字符流
      ByteArrayInputStream、ByteArrayOutputStream 字节数组流
      CharArrayReader、CharArrayWriter 字符数组流
  增强流（包装流）
    在节点流的基础上，提供了额外的功能和操作，是的IO操作更加高效、方便和灵活
    可以在节点流上添加缓冲、字符编码的转换、对象序列化等功能
  缓冲流（也叫高效流，属于增强流的一种）
    用于提高读取和写入数据的效率，在内存中引入缓冲区，来减少实际的IO操作次数，从而提高效率
    常见的缓冲流
      BufferedInputStream 缓冲字节输入流
      BufferedOutputStream 缓冲字节输出流
      BufferedReader 缓冲字符输入流
      BufferedWriter 缓冲字符输出流
动物类
    成员方法
      吃东西
      睡觉
    猫类
      继承重写父类的方法
    狗类
      继承重写父类的方法
